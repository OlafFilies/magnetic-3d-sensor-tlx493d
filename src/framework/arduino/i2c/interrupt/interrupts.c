/*
*****************************************************************************
* Copyright (C) 2019 Infineon Technologies AG. All rights reserved.
*
* Infineon Technologies AG (INFINEON) is supplying this file for use
* exclusively with Infineon's products. This file can be freely
* distributed within development tools and software supporting such microcontroller
* products.
*
* THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
* OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
* INFINEON SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR DIRECT, INDIRECT, INCIDENTAL,
* ASPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
*
******************************************************************************
*/


#include "conf_interrupts.h"
#include "interrupts.h"
#include "i2c.h"

#include <xmc_scu.h>
#include <stdbool.h>

// #include "src/TLx493D/TLx493D.h"
// #include "src/xmc1100/i2c/i2c.h"
#include "xmc_i2c.h"
// #include "src/debug/debug.h"
#include <xmc_gpio.h>
// #include "src/TLx493D/interface.h"



// static struct {
// 	volatile bool ignore_next_int_CCU;
// 	volatile bool ignore_next_int_ERU;
// 	volatile bool TLI_detected;
// } _local = {0};


void INT_init_ext_interrupts(void)
{
	// Enable External Interrupt on pin P2.11
	// (rising edge)
	XMC_ERU_ETL_Init(ERU0_ETL2, &CONF_SCL_PIN_INT_ERU);
	XMC_ERU_OGU_Init(ERU0_OGU0, &CONF_SCL_PIN_OGU);

	// { Enable External Interrupt on pin P0.0 }
	// (TLI support)
	// Input pullup P0.0
	const XMC_GPIO_CONFIG_t in_pull_up = {
	  .mode = XMC_GPIO_MODE_INPUT_PULL_UP,
	  .input_hysteresis = XMC_GPIO_INPUT_HYSTERESIS_STANDARD,
	};
	XMC_GPIO_Init(P0_0, &in_pull_up);

	// enable CCU4 clock
	XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);

	CCU40->GCTRL = (uint32_t)0;
	// Pin for event0: IN0C
	// Event on rising-edge
	CCU40_CC40->INS = (2u << CCU4_CC4_INS_EV0IS_Pos)
					| (1u << CCU4_CC4_INS_EV0EM_Pos);
	// capture triggered by event 0
	CCU40_CC40->CMC = (0x1u << CCU4_CC4_CMC_CAP0S_Pos);

	/* Set the prescaler value: clock is divided by 2^n, with n=0..15
	CCU40_CC41->PSC = 0x0001;   // divide 32MHz by 2^10 = 1024 --> 31250Hz */

	// period
	CCU40_CC40->PRS = 0xFFFFu;

	// set period using shadow
	CCU40->GCSS |= CCU4_GCSS_S0SE_Msk;

	/*Event 0 Service request selector
	This field selects to which slice Service request line,
	the interrupt generated by the Event 0 detection is
	going to be forwarded */

	/* request for slice 1 */
	// Forward Interrupt from Event0 to Slice 0 request line
	WR_REG(
		CCU40_CC40->SRS,
		CCU4_CC4_SRS_E0SR_Msk,
		CCU4_CC4_SRS_E0SR_Pos,
		(uint32_t)0x00
	);
	// Forward Interrupt from Period Match to Slice 0 request line
	WR_REG(
		CCU40_CC40->SRS,
		CCU4_CC4_SRS_POSR_Msk,
		CCU4_CC4_SRS_POSR_Pos,
		(uint32_t)0x00
	);

	/* enable int*/
	SET_BIT(CCU40_CC40->INTE, CCU4_CC4_INTE_E0AE_Pos);
	SET_BIT(CCU40_CC40->INTE, CCU4_CC4_INTE_PME_Pos);

	// reset timer on each capture event
	CCU40_CC40->TC=(0x3 << CCU4_CC4_TC_CAPC_Pos);

	// clear idle for CC40
	SET_BIT(CCU40->GIDLC, CCU4_GIDLC_CS0I_Pos);
	// start timer
	SET_BIT(CCU40_CC40->TCSET, CCU4_CC4_TCSET_TRBS_Pos);

	// disable interrupts
	NVIC_DisableIRQ(ERU0_0_IRQn);
	NVIC_DisableIRQ(CCU40_0_IRQn);

	NVIC_ClearPendingIRQ(ERU0_0_IRQn);
	NVIC_ClearPendingIRQ(CCU40_0_IRQn);

	// Set priority to 3 (lower priority)
	// Priorities are between 0..3
	// Must be multiplied by 64 (or left shift 6)
	NVIC_SetPriority(ERU0_0_IRQn, 3u << 6);
	NVIC_SetPriority(CCU40_0_IRQn, 3u << 6);


	//This CMSIS function configures slice 0 to priority level 0 (highest Priority)
	NVIC_SetPriority(CCU40_0_IRQn, 0xC0);
	//This function clears slice 0 pending status
	NVIC_ClearPendingIRQ(CCU40_0_IRQn);
	//This function enables slice 0 for interrupt request generation
	NVIC_EnableIRQ(CCU40_0_IRQn);
}


bool INT_get_TLI_detected(void)
{
	// return _local.TLI_detected;
}

/* Interrupt service routine called when an INT
 * signal is received on the I2C's SCL pin P2.11
 * */
void ERU0_0_IRQHandler()
{
	// if (_local.ignore_next_int_ERU) {
	// 	_local.ignore_next_int_ERU = false;
	// } else {
	// 	_local.ignore_next_int_CCU = true;

	// 	// notify GUI_sensor system that there is data available
	// 	#ifdef _DATA_READY
	// 	_DATA_READY();
	// 	#endif
	// }

	// Clear IRQ flags
	XMC_ERU_ETL_ClearStatusFlag(ERU0_ETL2);
}

/* Interrupt service routine called when an INT
 * signal is received on pin P0.0
 * (used on TLI493D_W2BW)
 * */
void CCU40_0_IRQHandler()
{
	// // only handle interrupt if caused by negedge
	// if ((CCU40_CC40->INTS >> CCU4_CC4_INTS_E0AS_Pos) & 1u) {
	// 	_local.TLI_detected = true;
	// 	if (_local.ignore_next_int_CCU) {
	// 		_local.ignore_next_int_CCU = false;
	// 	} else {
	// 		_local.ignore_next_int_ERU = true;

	// 		// notify GUI_sensor system that there is data available
	// 		#ifdef _DATA_READY
	// 		_DATA_READY();
	// 		#endif
	// 	}
	// }
}
